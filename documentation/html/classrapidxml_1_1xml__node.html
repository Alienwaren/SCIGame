<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>GameSCI: Dokumentacja szablonu klasy rapidxml::xml_node&lt; Ch &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Wygenerowano przez Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Szukaj');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Strona&nbsp;główna</span></a></li>
      <li><a href="namespaces.html"><span>Przestrzenie&nbsp;nazw</span></a></li>
      <li class="current"><a href="annotated.html"><span>Klasy</span></a></li>
      <li><a href="files.html"><span>Pliki</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Szukaj" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Lista&nbsp;klas</span></a></li>
      <li><a href="hierarchy.html"><span>Hierarchia&nbsp;klas</span></a></li>
      <li><a href="functions.html"><span>Składowe&nbsp;klas</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacerapidxml.html">rapidxml</a>::<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>
  </div>
</div>
<div class="contents">
<h1>Dokumentacja szablonu klasy rapidxml::xml_node&lt; Ch &gt;</h1><!-- doxytag: class="rapidxml::xml_node" --><!-- doxytag: inherits="rapidxml::xml_base" -->
<p><code>#include &lt;<a class="el" href="rapidxml_8hpp_source.html">rapidxml.hpp</a>&gt;</code></p>
<div class="dynheader">
Diagram dziedziczenia dla rapidxml::xml_node&lt; Ch &gt;</div>
<div class="dynsection">
 <div class="center">
  <img src="classrapidxml_1_1xml__node.gif" usemap="#rapidxml::xml_node&lt; Ch &gt;_map" alt=""/>
  <map id="rapidxml::xml_node&lt; Ch &gt;_map" name="rapidxml::xml_node&lt; Ch &gt;_map">
<area href="classrapidxml_1_1xml__base.html" alt="rapidxml::xml_base&lt; Ch &gt;" shape="rect" coords="0,0,184,24"/>
<area href="classrapidxml_1_1xml__document.html" alt="rapidxml::xml_document&lt; Ch &gt;" shape="rect" coords="0,112,184,136"/>
</map>
 </div>
</div>

<p><a href="classrapidxml_1_1xml__node-members.html">Lista wszystkich składowych.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Metody publiczne</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a8bd9019960b90605a45998b661fb1b0e">xml_node</a> (<a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__document.html">xml_document</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#adb6ad21a4590cf13d4a6a5036e3cdbbc">document</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a2ace550c18cf10da6303773972d7157f">last_node</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a001ece4e227eebbd6ad0ec7dacf1c00b">previous_sibling</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#ac59af4dd5f0ec715753e42467dff6aed">next_sibling</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a50c03f2db3fa51f27a73d86ec29a49d3">last_attribute</a> (const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a499bbc9300c1b06821d5c08b24164c68">type</a> (<a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#ae86e92908c3eab40bbed8216e4f3f3cb">prepend_node</a> (<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *child)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a8696d098ecc9c4d2a646b43e91d58e31">append_node</a> (<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *child)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a666880f42a7e486d78cc45ed51c7c46d">insert_node</a> (<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *where, <a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *child)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a62bf7b276cf7a651a3337f5e0a0ef6ac">remove_first_node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a9182512e948ec451a83f116cce7c7674">remove_last_node</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a98289923eb9e8889418a9eb0207ea35c">remove_node</a> (<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *where)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes specified child from the node.  <a href="#a98289923eb9e8889418a9eb0207ea35c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a95735358b079ae0adcfbbac69aa1fbc3">remove_all_nodes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all child nodes (but not attributes).  <a href="#a95735358b079ae0adcfbbac69aa1fbc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a8b62ee76489faf8e2d1210869d547684">prepend_attribute</a> (<a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a33ce3386f8c42dd4db658b75cbb6e6c4">append_attribute</a> (<a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a9fe659cdf4a5b3bbf5e8ffc98db5a84f">insert_attribute</a> (<a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *where, <a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#aa95192d2a165cca16c551ed2a2a06aec">remove_first_attribute</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a1781a2cbedc9a51d609ad5b528125635">remove_last_attribute</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#a6f97b1b4f46a94a4587915df3c0c6b57">remove_attribute</a> (<a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *where)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrapidxml_1_1xml__node.html#aa8d5d9484aa1eb5ff1841a073c84c1aa">remove_all_attributes</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all attributes of node.  <a href="#aa8d5d9484aa1eb5ff1841a073c84c1aa"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Opis szczegółowy</h2>
<h3>template&lt;class Ch = char&gt;<br/>
 class rapidxml::xml_node&lt; Ch &gt;</h3>

<p>Class representing a node of XML document. Each node may have associated name and value strings, which are available through <a class="el" href="classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name()</a> and <a class="el" href="classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value()</a> functions. Interpretation of name and value depends on type of the node. Type of node can be determined by using <a class="el" href="classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type()</a> function. <br/>
<br/>
 Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. Thus, this text must persist in the memory for the lifetime of node. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Ch</em>&nbsp;</td><td>Character type to use. </td></tr>
  </table>
  </dd>
</dl>
<hr/><h2>Dokumentacja konstruktora i destruktora</h2>
<a class="anchor" id="a8bd9019960b90605a45998b661fb1b0e"></a><!-- doxytag: member="rapidxml::xml_node::xml_node" ref="a8bd9019960b90605a45998b661fb1b0e" args="(node_type type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::<a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs an empty node with the specified type. Consider using <a class="el" href="classrapidxml_1_1memory__pool.html">memory_pool</a> of appropriate document to allocate nodes manually. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of node to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Dokumentacja funkcji składowych</h2>
<a class="anchor" id="a33ce3386f8c42dd4db658b75cbb6e6c4"></a><!-- doxytag: member="rapidxml::xml_node::append_attribute" ref="a33ce3386f8c42dd4db658b75cbb6e6c4" args="(xml_attribute&lt; Ch &gt; *attribute)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::append_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>attribute</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends a new attribute to the node. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>Attribute to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8696d098ecc9c4d2a646b43e91d58e31"></a><!-- doxytag: member="rapidxml::xml_node::append_node" ref="a8696d098ecc9c4d2a646b43e91d58e31" args="(xml_node&lt; Ch &gt; *child)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::append_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends a new child node. The appended child becomes the last child. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Node to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb6ad21a4590cf13d4a6a5036e3cdbbc"></a><!-- doxytag: member="rapidxml::xml_node::document" ref="adb6ad21a4590cf13d4a6a5036e3cdbbc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__document.html">xml_document</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::document </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets document of which node is a child. </p>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to document that contains this node, or 0 if there is no parent document. </dd></dl>

</div>
</div>
<a class="anchor" id="ae426802be58114ffc41bf30ac6b8c37d"></a><!-- doxytag: member="rapidxml::xml_node::first_attribute" ref="ae426802be58114ffc41bf30ac6b8c37d" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::first_attribute </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets first attribute of node, optionally matching attribute name. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found attribute, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dedeb4e04bb35e06a9a7bddf6ba652d"></a><!-- doxytag: member="rapidxml::xml_node::first_node" ref="a2dedeb4e04bb35e06a9a7bddf6ba652d" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::first_node </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets first child node, optionally matching node name. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found child, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe659cdf4a5b3bbf5e8ffc98db5a84f"></a><!-- doxytag: member="rapidxml::xml_node::insert_attribute" ref="a9fe659cdf4a5b3bbf5e8ffc98db5a84f" args="(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::insert_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>attribute</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new attribute at specified place inside the node. All attributes after and including the specified attribute are moved one position back. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Place where to insert the attribute, or 0 to insert at the back. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>Attribute to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a666880f42a7e486d78cc45ed51c7c46d"></a><!-- doxytag: member="rapidxml::xml_node::insert_node" ref="a666880f42a7e486d78cc45ed51c7c46d" args="(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::insert_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>child</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a new child node at specified place inside the node. All children after and including the specified node are moved one position back. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Place where to insert the child, or 0 to insert at the back. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Node to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50c03f2db3fa51f27a73d86ec29a49d3"></a><!-- doxytag: member="rapidxml::xml_node::last_attribute" ref="a50c03f2db3fa51f27a73d86ec29a49d3" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::last_attribute </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets last attribute of node, optionally matching attribute name. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found attribute, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ace550c18cf10da6303773972d7157f"></a><!-- doxytag: member="rapidxml::xml_node::last_node" ref="a2ace550c18cf10da6303773972d7157f" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::last_node </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets last child node, optionally matching node name. Behaviour is undefined if node has no children. Use <a class="el" href="classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node()</a> to test if node has children. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found child, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ac59af4dd5f0ec715753e42467dff6aed"></a><!-- doxytag: member="rapidxml::xml_node::next_sibling" ref="ac59af4dd5f0ec715753e42467dff6aed" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::next_sibling </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets next sibling node, optionally matching node name. Behaviour is undefined if node has no parent. Use <a class="el" href="classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent()</a> to test if node has a parent. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found sibling, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b62ee76489faf8e2d1210869d547684"></a><!-- doxytag: member="rapidxml::xml_node::prepend_attribute" ref="a8b62ee76489faf8e2d1210869d547684" args="(xml_attribute&lt; Ch &gt; *attribute)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::prepend_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>attribute</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepends a new attribute to the node. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>Attribute to prepend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae86e92908c3eab40bbed8216e4f3f3cb"></a><!-- doxytag: member="rapidxml::xml_node::prepend_node" ref="ae86e92908c3eab40bbed8216e4f3f3cb" args="(xml_node&lt; Ch &gt; *child)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::prepend_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>child</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepends a new child node. The prepended child becomes the first child, and all existing children are moved one position back. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>child</em>&nbsp;</td><td>Node to prepend. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a001ece4e227eebbd6ad0ec7dacf1c00b"></a><!-- doxytag: member="rapidxml::xml_node::previous_sibling" ref="a001ece4e227eebbd6ad0ec7dacf1c00b" args="(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;* <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::previous_sibling </td>
          <td>(</td>
          <td class="paramtype">const Ch *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>name_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>case_sensitive</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets previous sibling node, optionally matching node name. Behaviour is undefined if node has no parent. Use <a class="el" href="classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent()</a> to test if node has a parent. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_size</em>&nbsp;</td><td>Size of name, in characters, or 0 to have size calculated automatically from string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>case_sensitive</em>&nbsp;</td><td>Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Pointer to found sibling, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8d5d9484aa1eb5ff1841a073c84c1aa"></a><!-- doxytag: member="rapidxml::xml_node::remove_all_attributes" ref="aa8d5d9484aa1eb5ff1841a073c84c1aa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_all_attributes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all attributes of node. </p>

</div>
</div>
<a class="anchor" id="a95735358b079ae0adcfbbac69aa1fbc3"></a><!-- doxytag: member="rapidxml::xml_node::remove_all_nodes" ref="a95735358b079ae0adcfbbac69aa1fbc3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_all_nodes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all child nodes (but not attributes). </p>

</div>
</div>
<a class="anchor" id="a6f97b1b4f46a94a4587915df3c0c6b57"></a><!-- doxytag: member="rapidxml::xml_node::remove_attribute" ref="a6f97b1b4f46a94a4587915df3c0c6b57" args="(xml_attribute&lt; Ch &gt; *where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__attribute.html">xml_attribute</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>where</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes specified attribute from node. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>where</em>&nbsp;</td><td>Pointer to attribute to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa95192d2a165cca16c551ed2a2a06aec"></a><!-- doxytag: member="rapidxml::xml_node::remove_first_attribute" ref="aa95192d2a165cca16c551ed2a2a06aec" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_first_attribute </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes first attribute of the node. If node has no attributes, behaviour is undefined. Use <a class="el" href="classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute()</a> to test if node has attributes. </p>

</div>
</div>
<a class="anchor" id="a62bf7b276cf7a651a3337f5e0a0ef6ac"></a><!-- doxytag: member="rapidxml::xml_node::remove_first_node" ref="a62bf7b276cf7a651a3337f5e0a0ef6ac" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_first_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes first child node. If node has no children, behaviour is undefined. Use <a class="el" href="classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node()</a> to test if node has children. </p>

</div>
</div>
<a class="anchor" id="a1781a2cbedc9a51d609ad5b528125635"></a><!-- doxytag: member="rapidxml::xml_node::remove_last_attribute" ref="a1781a2cbedc9a51d609ad5b528125635" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_last_attribute </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes last attribute of the node. If node has no attributes, behaviour is undefined. Use <a class="el" href="classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute()</a> to test if node has attributes. </p>

</div>
</div>
<a class="anchor" id="a9182512e948ec451a83f116cce7c7674"></a><!-- doxytag: member="rapidxml::xml_node::remove_last_node" ref="a9182512e948ec451a83f116cce7c7674" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_last_node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes last child of the node. If node has no children, behaviour is undefined. Use <a class="el" href="classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node()</a> to test if node has children. </p>

</div>
</div>
<a class="anchor" id="a98289923eb9e8889418a9eb0207ea35c"></a><!-- doxytag: member="rapidxml::xml_node::remove_node" ref="a98289923eb9e8889418a9eb0207ea35c" args="(xml_node&lt; Ch &gt; *where)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrapidxml_1_1xml__node.html">xml_node</a>&lt; Ch &gt; *&nbsp;</td>
          <td class="paramname"> <em>where</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes specified child from the node. </p>

</div>
</div>
<a class="anchor" id="a499bbc9300c1b06821d5c08b24164c68"></a><!-- doxytag: member="rapidxml::xml_node::type" ref="a499bbc9300c1b06821d5c08b24164c68" args="(node_type type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets type of node. </p>
<dl><dt><b>Parametry:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of node to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c6a4315b98bcfa2e04fed3fa1b22c36"></a><!-- doxytag: member="rapidxml::xml_node::type" ref="a2c6a4315b98bcfa2e04fed3fa1b22c36" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ch = char&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> <a class="el" href="classrapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt; Ch &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets type of node. </p>
<dl class="return"><dt><b>Zwraca:</b></dt><dd>Type of node. </dd></dl>

</div>
</div>
<hr/>Dokumentacja dla tej klasy została wygenerowana z pliku:<ul>
<li>C:/Documents and Settings/Jacek/Moje dokumenty/Visual Studio 2008/Projects/GameSCI/GameSCI/source/XML/RapidXML/<a class="el" href="rapidxml_8hpp_source.html">rapidxml.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Klasy</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Przestrzenie nazw</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Pliki</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Funkcje</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Zmienne</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Definicje typów</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Wyliczenia</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Wartości wyliczeń</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Przyjaciele</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Definicje</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Wygenerowano Tue Nov 26 15:18:18 2013 dla GameSCI programem&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
